-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package ASV
@version 0.1.0.0


-- | |
module Manager.Args

-- | All data collated from command line arguments
data Options
Options :: FilePath -> FilePath -> FilePath -> String -> Options

-- | Work directory argument Where the VHDL WORK library files are stored
--   Arg: "--work-dir" Default: "work/"
[workDir] :: Options -> FilePath

-- | IEEE directory argument Where the VHDL IEEE library files are stored
--   Arg: "--ieee-dir" Default: "ieee/"
[ieeeDir] :: Options -> FilePath

-- | Build directory argument Where the tool outputs simulation files to
--   Arg: "--build-dir" Default: "build/"
[buildDir] :: Options -> FilePath

-- | Top module argument The name of the top level VHDL design entity Arg:
--   "--top" Default: N/A
[topModule] :: Options -> String

-- | Command line argument parser For details of the argument data stored,
--   see type <a>Options</a>
optionsGroup :: Parser Options


-- | |
module Parser.Combinators.Lex.Internal

-- | Parse a graphic character Returns parsed character <tt>
--   graphic_character ::= basic_graphic_character | lower_case_letter |
--   other_special_character </tt>
graphicCharacter :: Parser Char

-- | Parse a basic graphic character Returns parsed character <tt>
--   basic_graphic_character ::= upper_case_letter | digit |
--   special_character | space_character </tt>
basicGraphicCharacter :: Parser Char

-- | Parse a basic character Returns parsed character <tt> basic_character
--   ::= basic_graphic_character | format_effector </tt>
basicCharacter :: Parser Char

-- | Parse an upper case letter Returns parsed character <tt> upper case
--   letters A B C D E F G H I J K L M N O P Q R S T U V W X Y Z </tt>
upperCaseLetter :: Parser Char

-- | Parse a special character Returns parsed character <tt> special
--   characters " # &amp; ' ( ) * + , - . / : ; <a>=</a> _ | </tt>
specialCharacter :: Parser Char

-- | Parse the space character Returns the space character
spaceCharacter :: Parser Char

-- | Parse a format effector Returns parsed character
formatEffector :: Parser Char

-- | Parse a lower case letter Returns parsed character <tt> upper case
--   letters a b c d e f g h i j k l m n o p q r s t u v w x y z </tt>
lowerCaseLetter :: Parser Char

-- | Parse an other special character Returns parsed character <tt> other
--   special characters ! $ % </tt> ? [ ] ^ ` { } ~ @
otherSpecialCharacter :: Parser Char

-- | Parses a letter or digit Returns parsed character <tt> letter_or_digit
--   ::= letter | digit </tt>
letterOrDigit :: Parser Char

-- | Parses a letter Returns parsed character <tt> letter ::=
--   upper_case_letter | lower_case_letter </tt>
letter :: Parser Char

-- | Parses an integer Returns the <a>String</a> of the integer <tt>
--   integer ::= digit { [ underline ] digit } </tt>
integer :: Parser String

-- | Parses an exponent Returns the <a>Integer</a> exponent value <tt>
--   exponent ::= E [ + ] integer | E - integer </tt> NOTE: - Case
--   insensitive E
exponent' :: Parser Integer


-- | |
module Parser.Combinators.ReservedWords.Internal

-- | Parse a character, ignoring case Parses <a>Char</a> input (upper or
--   lower case) Returns upper case character parsed
caseInsensitiveChar :: Char -> Parser Char

-- | Parses a keyword, ignoring case Parses <a>String</a> input (upper or
--   lower case) Returns '()'
keywordParser :: String -> Parser ()


-- | |
module Parser.Combinators.ReservedWords

-- | Parses the keyword "abs", ignoring case Returns '()'
absKeyword :: Parser ()

-- | Parses the keyword "access", ignoring case Returns '()'
accessKeyword :: Parser ()

-- | Parses the keyword "after", ignoring case Returns '()'
afterKeyword :: Parser ()

-- | Parses the keyword "alias", ignoring case Returns '()'
aliasKeyword :: Parser ()

-- | Parses the keyword "all", ignoring case Returns '()'
allKeyword :: Parser ()

-- | Parses the keyword "and", ignoring case Returns '()'
andKeyword :: Parser ()

-- | Parses the keyword "architecture", ignoring case Returns '()'
architectureKeyword :: Parser ()

-- | Parses the keyword "array", ignoring case Returns '()'
arrayKeyword :: Parser ()

-- | Parses the keyword "assert", ignoring case Returns '()'
assertKeyword :: Parser ()

-- | Parses the keyword "attribute", ignoring case Returns '()'
attributeKeyword :: Parser ()

-- | Parses the keyword "begin", ignoring case Returns '()'
beginKeyword :: Parser ()

-- | Parses the keyword "block", ignoring case Returns '()'
blockKeyword :: Parser ()

-- | Parses the keyword "body", ignoring case Returns '()'
bodyKeyword :: Parser ()

-- | Parses the keyword "buffer", ignoring case Returns '()'
bufferKeyword :: Parser ()

-- | Parses the keyword "bus", ignoring case Returns '()'
busKeyword :: Parser ()

-- | Parses the keyword "case", ignoring case Returns '()'
caseKeyword :: Parser ()

-- | Parses the keyword "component", ignoring case Returns '()'
componentKeyword :: Parser ()

-- | Parses the keyword "configuration", ignoring case Returns '()'
configurationKeyword :: Parser ()

-- | Parses the keyword "constant", ignoring case Returns '()'
constantKeyword :: Parser ()

-- | Parses the keyword "disconnect", ignoring case Returns '()'
disconnectKeyword :: Parser ()

-- | Parses the keyword "downto", ignoring case Returns '()'
downtoKeyword :: Parser ()

-- | Parses the keyword "else", ignoring case Returns '()'
elseKeyword :: Parser ()

-- | Parses the keyword "elsif", ignoring case Returns '()'
elsifKeyword :: Parser ()

-- | Parses the keyword "end", ignoring case Returns '()'
endKeyword :: Parser ()

-- | Parses the keyword "entity", ignoring case Returns '()'
entityKeyword :: Parser ()

-- | Parses the keyword "exit", ignoring case Returns '()'
exitKeyword :: Parser ()

-- | Parses the keyword "file", ignoring case Returns '()'
fileKeyword :: Parser ()

-- | Parses the keyword "for", ignoring case Returns '()'
forKeyword :: Parser ()

-- | Parses the keyword "function", ignoring case Returns '()'
functionKeyword :: Parser ()

-- | Parses the keyword "generate", ignoring case Returns '()'
generateKeyword :: Parser ()

-- | Parses the keyword "generic", ignoring case Returns '()'
genericKeyword :: Parser ()

-- | Parses the keyword "guarded", ignoring case Returns '()'
guardedKeyword :: Parser ()

-- | Parses the keyword "if", ignoring case Returns '()'
ifKeyword :: Parser ()

-- | Parses the keyword "in", ignoring case Returns '()'
inKeyword :: Parser ()

-- | Parses the keyword "inout", ignoring case Returns '()'
inoutKeyword :: Parser ()

-- | Parses the keyword "is", ignoring case Returns '()'
isKeyword :: Parser ()

-- | Parses the keyword "label", ignoring case Returns '()'
labelKeyword :: Parser ()

-- | Parses the keyword "library", ignoring case Returns '()'
libraryKeyword :: Parser ()

-- | Parses the keyword "linkage", ignoring case Returns '()'
linkageKeyword :: Parser ()

-- | Parses the keyword "loop", ignoring case Returns '()'
loopKeyword :: Parser ()

-- | Parses the keyword "map", ignoring case Returns '()'
mapKeyword :: Parser ()

-- | Parses the keyword "mod", ignoring case Returns '()'
modKeyword :: Parser ()

-- | Parses the keyword "nand", ignoring case Returns '()'
nandKeyword :: Parser ()

-- | Parses the keyword "new", ignoring case Returns '()'
newKeyword :: Parser ()

-- | Parses the keyword "next", ignoring case Returns '()'
nextKeyword :: Parser ()

-- | Parses the keyword "nor", ignoring case Returns '()'
norKeyword :: Parser ()

-- | Parses the keyword "not", ignoring case Returns '()'
notKeyword :: Parser ()

-- | Parses the keyword "null", ignoring case Returns '()'
nullKeyword :: Parser ()

-- | Parses the keyword "of", ignoring case Returns '()'
ofKeyword :: Parser ()

-- | Parses the keyword "on", ignoring case Returns '()'
onKeyword :: Parser ()

-- | Parses the keyword "open", ignoring case Returns '()'
openKeyword :: Parser ()

-- | Parses the keyword "or", ignoring case Returns '()'
orKeyword :: Parser ()

-- | Parses the keyword "others", ignoring case Returns '()'
othersKeyword :: Parser ()

-- | Parses the keyword "out", ignoring case Returns '()'
outKeyword :: Parser ()

-- | Parses the keyword "package", ignoring case Returns '()'
packageKeyword :: Parser ()

-- | Parses the keyword "port", ignoring case Returns '()'
portKeyword :: Parser ()

-- | Parses the keyword "procedure", ignoring case Returns '()'
procedureKeyword :: Parser ()

-- | Parses the keyword "process", ignoring case Returns '()'
processKeyword :: Parser ()

-- | Parses the keyword "range", ignoring case Returns '()'
rangeKeyword :: Parser ()

-- | Parses the keyword "record", ignoring case Returns '()'
recordKeyword :: Parser ()

-- | Parses the keyword "register", ignoring case Returns '()'
registerKeyword :: Parser ()

-- | Parses the keyword "rem", ignoring case Returns '()'
remKeyword :: Parser ()

-- | Parses the keyword "report", ignoring case Returns '()'
reportKeyword :: Parser ()

-- | Parses the keyword "return", ignoring case Returns '()'
returnKeyword :: Parser ()

-- | Parses the keyword "select", ignoring case Returns '()'
selectKeyword :: Parser ()

-- | Parses the keyword "severity", ignoring case Returns '()'
severityKeyword :: Parser ()

-- | Parses the keyword "signal", ignoring case Returns '()'
signalKeyword :: Parser ()

-- | Parses the keyword "subtype", ignoring case Returns '()'
subtypeKeyword :: Parser ()

-- | Parses the keyword "then", ignoring case Returns '()'
thenKeyword :: Parser ()

-- | Parses the keyword "to", ignoring case Returns '()'
toKeyword :: Parser ()

-- | Parses the keyword "transport", ignoring case Returns '()'
transportKeyword :: Parser ()

-- | Parses the keyword "type", ignoring case Returns '()'
typeKeyword :: Parser ()

-- | Parses the keyword "units", ignoring case Returns '()'
unitsKeyword :: Parser ()

-- | Parses the keyword "until", ignoring case Returns '()'
untilKeyword :: Parser ()

-- | Parses the keyword "use", ignoring case Returns '()'
useKeyword :: Parser ()

-- | Parses the keyword "variable", ignoring case Returns '()'
variableKeyword :: Parser ()

-- | Parses the keyword "wait", ignoring case Returns '()'
waitKeyword :: Parser ()

-- | Parses the keyword "when", ignoring case Returns '()'
whenKeyword :: Parser ()

-- | Parses the keyword "while", ignoring case Returns '()'
whileKeyword :: Parser ()

-- | Parses the keyword "with", ignoring case Returns '()'
withKeyword :: Parser ()

-- | Parses the keyword "xor", ignoring case Returns '()'
xorKeyword :: Parser ()


-- | |
module Parser.Types.Token.Internal

-- | Upper case string data Only permitted to contain upper case characters
newtype UpperString
UpperString :: ByteString -> UpperString

-- | Bit string data Only permitted to contain characters '0' and '1'
newtype BitString
BitString :: ByteString -> BitString
instance GHC.Classes.Eq Parser.Types.Token.Internal.BitString
instance GHC.Classes.Eq Parser.Types.Token.Internal.UpperString
instance GHC.Show.Show Parser.Types.Token.Internal.BitString
instance GHC.Show.Show Parser.Types.Token.Internal.UpperString


-- | |
module Parser.Types.Token

-- | Upper case string data Only permitted to contain upper case characters
data UpperString

-- | Upper case string constructor Converts string to upper case and packs
--   it into a bytestring
mkUpperString :: String -> UpperString

-- | Abstract literal value <tt> abstract_literal ::= decimal_literal |
--   based_literal </tt> = NOTE Lexed output does not match tree
--   specification There are two acceptable types of this literal * Decimal
--   Literals * Based Literals The lexer converts both of these to their
--   representative value: * Integer value * Real - Floating point value
data AbstractLiteral

-- | Universal integer type value Implemented with Haskell <a>Int64</a>
--   type
UniversalInteger :: Int64 -> AbstractLiteral

-- | Universal real type value Implemented with Haskell <a>Double</a> type
UniversalReal :: Double -> AbstractLiteral

-- | Bit string data Only permitted to contain characters '0' and '1'
data BitString

-- | Bit string constructor Forces string to contain '0' and '1' and packs
--   it into a bytestring Error if string contains any characters other
--   than '0' or '1'
mkBitString :: String -> BitString
instance GHC.Show.Show Parser.Types.Token.AbstractLiteral
instance GHC.Classes.Eq Parser.Types.Token.AbstractLiteral


-- | |
module Parser.Combinators.Lex

-- | Parses an identifier Returns upper case string form of the identifier
--   (<a>UpperString</a>) <tt> identifier ::= letter { [ underliner ]
--   letter_or_digit } </tt>
identifier :: Parser UpperString

-- | Parses an abstract literal Returns the parsed <a>AbstractLiteral</a>
--   value <tt> abstract_literal ::= decimal_literal | based_literal
--   decimal_literal ::= integer [ . integer ] [ exponent ] based_literal
--   ::= base [ exponent ] base ::= integer based_integer ::=
--   extended_digit { [ underline ] extended_digit } extended_digit ::=
--   digit | letter </tt> NOTE: - Underline is ignored - Base determines
--   valid extended_digit set - extended_digit is case insensitive
abstractLiteral :: Parser AbstractLiteral

-- | Parses a character literal Returns the <a>Char</a> literal (without
--   the containing ''' characters) <tt> character_literal ::= '
--   graphic_character ' </tt>
characterLiteral :: Parser Char

-- | Parses a string literal Returns the <a>String</a> literal (without the
--   containing '"' characters) <tt> string_literal ::= " {
--   graphic_character } " </tt> NOTE: - Can use character <tt>%</tt>
--   instead of '"' - To use the container character within the string,
--   must repeat the character
stringLiteral :: Parser String

-- | Parses a bit string literal Returns the parsed bit string literal <tt>
--   bit_string_literal ::= base_specifier " bit_value " bit_value ::=
--   extended_digit { [ underline ] extended_digit } base_specifier ::= B |
--   O | X </tt> NOTE: - Base specifier is case insensitive - Can use
--   character <tt>%</tt> instead of '"' - Extended digit depends on base
--   specifier
--   
--   If base specifier == B: <tt> extended_digit ::= 0 | 1 </tt> If base
--   specifier == O: <tt> extended_digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
--   </tt> If base specifier == X: <tt> extended_digit ::= 0 | 1 | 2 | 3 |
--   4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F </tt> NOTE: - Extended
--   digit is case insensitive
bitStringLiteral :: Parser BitString

-- | Parses a comment Returns '()' - Comments start with the string "--" -
--   Comments continue to the end of a line
comment :: Parser ()
