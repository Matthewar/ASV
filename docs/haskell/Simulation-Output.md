# Simulation Output
This page details the formatting and descriptions of the files generated by this tool.
These files are compiled to create the simulation binary.

## Default Modules
Some modules are automatically generated without custom data, these have boilerplate code and built-in functionality.

### VHDL-Sim.cabal
The cabal file is generated of two sections:
- A constant section, with the basic data cabal requires:
   - Name, version, source directory, other necessary fields
   - Default modules: `Top`, `Control`, `STD.STANDARD`
   - Required libraries:
      - [mtl](https://hackage.haskell.org/package/mtl): Exception monad
      - [containers](https://hackage.haskell.org/package/containers): Map data structure
      - [transformers](https://hackage.haskell.org/package/transformers): State monad transformer
      - [optparse-applicative](https://hackage.haskell.org/package/optparse-applicative): Command line argument parsing
      - Note: Stack automatically installs these
- An automated section:
   - List of module names generated by the tool

Located in `<build-dir>/VHDL-Sim.cabal`.

Relevant module `Sim.Builtin.Cabal`, found [here](/src/Sim/Builtin/Cabal.hs).

### stack.yaml
Constant `stack.yaml` file, required for stack to recognise `<build-dir>` as a stack project.

Located in `<build-dir>/stack.yaml`.

Relevant module `Sim.Builtin.Stack`, found [here](/src/Sim/Builtin/Stack.hs).

### Main
Main module for executable:
- Parses test arguments
   - `max-time`: Maximum time to run the simulation for
- Calls Top module

Located in `<build-dir>/Main.hs`.

Relevant module `Sim.Builtin.MainModule`, found [here](/src/Sim/Builtin/MainModule.hs).

### Control
Built in functions to control the flow of the simulation.

Located in `<build-dir>/Control.hs`.

Relevant module `Sim.Builtin.ControlModule`, found [here](/src/Sim/Builtin/ControlModule.hs).

#### Types
| Type | Description |
| :--- | :---------- |
| Control'Time | Simulation time type. Contains both the real time (VHDL type `STD.STANDARD.TIME`) and current delta (point within the current time frame). Has VHDL _Ord_ instance and _SignalOutput_ instance. |
| Entity'State | See description [here](#Entity'State). |
| Entity'Stack | Monad stack for components: component state, time , error tracker, exceptions, IO. |
| ProcessStatement | See description [here](#ProcessStatement). |
| Control'Signal | See description [here](#Control'Signal). |
| Control'Stack | Monad stack for control functions: time, error tracker, exceptions, IO. |
| Control'SEVERITY_TRACKER | Tracks number of warnings and errors that have occurred during the simulation. Also has show instance for output at end of simulation. |
| Control'SEVERITY_FAILURE | Holds severity failure string, used in monad stack as exception result. |

Note: Having removed monads from the current design, potentially not using:
- Entity'Stack
- Control'Stack
- Control'SEVERITY_FAILURE

##### Entity'State
Component state, containing all data stored and used in a component.
IE the signal values:
- Input ports
- Internal signals
- Output ports

Implementation:
```haskell
data Entity'State portsInType stateType portsOutType =
   Entity'State
      { entity'portsIn :: portsInType
      , entity'state :: stateType
      , entity'portsOut :: portsOutType
      }
```
##### ProcessStatement
Control mechanism for processes.
Various control statements (for changing flow of process) and state change statements (for updating signal values).

Available statements:
- Wait statement
   - Sensitivity list expression
      - Contains generated expression that returns true if an event occurs on a signal in the sensitivity list
      - `Entity'State a b c -> Bool`
      - `\_ -> False` if sensitivity list is not provided and provided condition is missing or has no signals in it
   - Condition expression
      - Generated expression from condition in design
      - `Entity'State a b c -> Control'Time -> STD.STANDARD.Type'ANON'BOOLEAN`
   - Wait time
      - Either:
         - Calculated time
            - Next `STD.STANDARD.Type'ANON'TIME` value when the expression expires
         - Calculation for wait time
            - Generated time expression from `for` clause
            - `\_ _ -> Nothing` if for clause not provided
            - `Entity'State a b c -> Control'Time -> Maybe STD.STANDARD.Type'ANON'TIME`
- If statement
   - Condition expression
      - Generated expression from condition in design
      - `Entity'State a b c -> Control'Time -> STD.STANDARD.Type'ANON'BOOLEAN`
   - True statements
      - Nested process statements if condition is true
   - False statements
      - Nested process statements if condition is not true
- Assert statement
   - Component name
   - Condition expression
      - Generated expression from condition in design
      - `Entity'State a b c -> Control'Time -> STD.STANDARD.Type'ANON'BOOLEAN`
   - Report expression
      - Generated expression from 'report' clause
      - Message to be printed in assertion statement (in VHDL string type)
      - `Entity'State a b c -> Control'Time -> STD.STANDARD.Type'ANON'STRING`
   - Severity expression
      - Generated expression from 'severity' clause
      - Severity level of assertion statement
      - `Entity'State a b c -> Control'Time -> STD.STANDARD.Type'ANON'SEVERITY_LEVEL`
- Regular statement
   - Any other statement is converted to this
   - Contains a generated expression that modifies the state as specified in the design
   - `Entity'State a b c -> Control'Time -> Entity'State a b c`
- End
   - Contains no other information
   - Stops the process until the next delta

Note:
- End statement is not used

##### Control'Signal
Data within a signal:
- Transactions (list of time and signal value pairs)
- Active marker
- Event marker 

Implementation:
```haskell
data Control'Signal a =
   Control'Signal
      { control'signal'transactions :: [(Control'Time,a)]
      , control'signal'active :: Bool
      , control'signal'event :: Bool
      }
```

#### Functions
| Function | Description |
| :------- | :---------- |
| progressProcess | Takes a set of process statements and progresses the simulation up until the next suspension of the process. |
| progressComponent | Takes a component (list of processes within the component) and progresses the simulation for all processes within the component. |
| processTime | Finds the lowest time within the component's processes. Returns `Nothing` if no times available, `Just (Right val)` if minimum time found, `Just (Left ())` if progressing to next delta (minimum time jump). |
| control'printInitial | Outputs initial signal values to the simulation output. |
| control'updateSignal | Updates signal value (adjusts transactions according to next time and modifies markers accordingly) and prints any signal changes to the simulation output. |
| control'readSignal | Read the current value of a signal. |
| control'updateSignal'inertial | Add new waveforms to a signal using the inertial delay method (as described in 1076-1987). |
| control'delayCheck | Check whether a non-static delay expression evaluates to a non-negative time. Error if it is negative. |
| control'jumpTime | Jump forward to specified time value. |
| control'assertNote | Print NOTE level assertion to simulation output. |
| control'assertWarning | Print WARNING level assertion to simulation output. |
| control'assertError | Print ERROR level assertion to simulation output. |
| control'assertFailure | Print FAILURE level assertion to simulation output. |

Note, potentially not using:
- control'jumpTime

##### Internal Functions
| Function | Description |
| :------- | :---------- |
| anon'stringToString | Convert VHDL `STD.STANDARD.STRING` type to Haskell `String` (`[Char]`) for printing to simulation output. |
| anon'characterToChar | Convert VHDL `STD.STANDARD.CHARACTER` type to Haskell `Char` for printing to simulation output. |
| control'assert | Print assertion message to simulation output. |

#### Constants
| Constant | Description |
| :------- | :---------- |
| initialTime | Starting time, used for the initial time in initial state declarations. |
| maxWaitTime | Maximum time value that a wait statement can be set to. Upper bound of Int64 used for real time value. |

### STD.STANDARD
This is the VHDL standard package as specified in IEEE 1076-1987.
Most of this has been autogenerated with this tool, however it also has additional non-standard parts:
- Logical functions (only builtin for types _STD.STANDARD.BOOLEAN_ and _STD.STANDARD.BIT_)
- Haskell typeclass for outputting signals
- Conversion of `Bool` Haskell type to `STD.STANDARD.BOOLEAN` VHDL type (used for autogenerated comparisons)
- SignalOutput typeclass used to convert the type value to a waveform value

This is located in `<build-dir>/src/STD/STANDARD.hs`.

Relevant module `Sim.Builtin.STD.STANDARD`, found [here](/src/Sim/Builtin/STD/STANDARD.hs).

## Fully Generated Modules
### Components (Entities and Architectures)
Entities and architectures are outputted in the form of the component modules:
- If no architecture exists for an entity, just the entity is converted to the component
- If an architecture exists then it is merged with the entity and converted to the component

Generated in `Sim.Output.Components` module.

#### Module Names
Entities and architectures names are ignored, they are renamed to a component name:
- `<LIBRARY>.<ENTITY>'COMPONENT'<COMPONENT>`
- `<LIBRARY>.<ENTITY>'COMPONENT'<COMPONENT>'GENERICS` (see [Generics](#Generics))

| Symbol | Meaning |
| :----- | :------ |
| `<LIBRARY>` | Library name |
| `<ENTITY>` | Entity name |
| `<COMPONENT>` | Component name |

##### Component Names
Component names are a list showing the hierarchy from _TOP_ to the current component name.

E.g. For a component name `i_component` imported in the component `i_middle`, where `i_middle` is imported in the module module, the component name would be: `TOP'I_MIDDLE'I_COMPONENT`

#### State
There are three similar components of the state (signals), and one additional part (processes).

##### Signals
- Input ports
- Output ports
- Internal signals

NOTE: Not yet implemented ports of type other than in/out.

```haskell
data <STATEPART> =
   <STATEPART>
      {
         -- List of signals in state
      }
```
Where `<STATEPART>` is:
- `PORTS'IN` for input ports
- `PORTS'OUT` for output ports
- `STATE` for internal signals
And the signal names within the state follow the scheme:
- `ports'in'<PORTNAME>` for input ports
- `ports'out'<PORTNAME>` for output ports
- `signal'<PORTNAME>` for internal signals

###### Default Values
Each state has an associated initial value:
```haskell
initial'<STATEPART> =
   <STATEPART>
      {
         -- List of initial values
      }
```

##### Processes
Processes have an associated state which holds two important data:
- Wait statement state: Particularly for processes with more than one wait statement, this determines where in the sequence of sequential statements the process is currently suspended at
- Wait statement time: The timeout value for the current wait statement the process is at

```haskell
data PROCESSES =
   PROCESSES
      {
         -- Process states
      }
```

##### Process Names
The process states are named according to their label.
If a label is not provided they are give the name `ANON'<ID>`, where `<ID>` is an incrementing integer from 0.

Process states are named `processes'<NAME>` where `<NAME>` is as described above.
The process state has type `(Int,STD.STANDARD.Type'ANON'TIME)`.

###### Default Values
The process initial value is generated in `Sim.Output.Processes` module.

#### Functions
Components have a number of inherent functions defined that are used by the module that instantiates them to interface with the component.

##### Initial State
```haskell
initialStack =
   Entity'State
      initial'PORTS'IN
      initial'STATE
      initial'PORTS'OUT
      initial'PROCESSES
```
A fixed function that uses the internally namespaced initial states to form an entire initial state for the component.

##### All Times
The `allTimes` function is a monadic function with the type signature `Entity'<COMPONENT>'Stack (Maybe STD.STANDARD.Type'ANON'TIME)`.
This returns the next time this component has something to do:
- Wait statement timeout
- Signal update

##### Any Ready
Similar to the `allTimes` function, this monitors whether any signals will update in the next delta.
This is used to check whether the simulation should increment the delta, and remain within the current real time period.
Otherwise, it uses the `allTimes` function to jump to the next time.

##### Initial Update
The `initialUpdate` function calls the `control'printInitial` function for all signals within the component to print initial values of signals.

##### Normal Update
`signalUpdate` function updates the signal values for all signals within the component (and prints the signal values to the output).

##### Component Stack
Type `Entity'<COMPONENT>'Stack` is a custom form of `Entity'Stack` with a state setup for this component.

##### Component Control
The top level control function is `entityControl`, this calls all necessary processes, etc.

#### Generics
To add portability, components are generated the same way no matter how generic and port maps for the component are assigned.
Port values are non-static and part of the state.
Generics are implemented through making a separate file with just these constants.
- The name of this file is `<build-dir>/src/<LIBRARY>/<ENTITY>'COMPONENT'<COMPONENT>'GENERICS`
- This is imported in the component file and is the difference between the same components with different generics

NOTE: Currently, each component is generated separately.
This isn't very efficient, should be generating a single component Haskell module body and attach different headers (with different import statements and module names).
Because they are not independent, each component contains a list (next to the state), showing the values of the imported generics.

#### Top Module
Special case of component

### Packages

## Generated Declarations
