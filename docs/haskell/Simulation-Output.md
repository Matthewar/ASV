# Simulation Output
This page details the formatting and descriptions of the files generated by this tool.
These files are compiled to create the simulation binary.

## Default Modules
Some modules are automatically generated without custom data, these have boilerplate and built in functionality.

### VHDL-Sim.cabal
The cabal file is generated of two sections:
- A constant section, with the basic data cabal requires:
   - Name, version, source directory, other necessary fields
   - Default modules: `Top`, `Control`, `STD.STANDARD`
   - Required libraries: mtl, containers, transformers, optparse-applicative
- An automated section:
   - List of module names generated by the tool

Located in `<build-dir>/VHDL-Sim.cabal`.

### stack.yaml
Constant `stack.yaml` file, required for stack to recognise `<build-dir>` as a stack project.

Located in `<build-dir>/stack.yaml`.

### Main
Main module for executable:
- Parses test arguments
   - `max-time`: Maximum time to run the simulation for
- Calls Top module

Located in `<build-dir>/Main.hs`.

### Control
Built in functions to control the flow of the simulation.

Located in `<build-dir>/Control.hs`.

#### Types
| Type | Description |
| :--- | :---------- |
| Control'Time | Simulation time type. Contains both the real time (VHDL type `STD.STANDARD.TIME`) and current delta (point within the current time frame). Has VHDL _Ord_ instance and _SignalOutput_ instance. |
| Entity'State | Component state, containing all data stored and used in a component. |
| Entity'Stack | Monad stack for components: component state, time , error tracker, exceptions, IO. |
| Control'Signal | Data within a signal: Transactions (list of time and signal value pairs), active marker, event marker. |
| Control'Stack | Monad stack for control functions: time, error tracker, exceptions, IO. |
| Control'SEVERITY_TRACKER | Tracks number of warnings and errors that have occurred during the simulation. Also has show instance for output at end of simulation. |
| Control'SEVERITY_FAILURE | Holds severity failure string, used in monad stack as exception result. |

#### Functions
| Function | Description |
| :------- | :---------- |
| control'printInitial | Outputs initial signal values to the simulation output. |
| control'updateSignal | Updates signal value (adjusts transactions according to next time and modifies markers accordingly) and prints any signal changes to the simulation output. |
| control'readSignal | Read the current value of a signal. |
| control'updateSignal'inertial | Add new waveforms to a signal using the inertial delay method (as described in 1076-1987). |
| control'delayCheck | Check whether a non-static delay expression evaluates to a non-negative time. Error if it is negative. |
| control'jumpTime | Jump forward to specified time value. |
| control'incrementWarnings | Increment number of warnings occurred in the simulation state. |
| control'incrementErrors | Increment number of errors occurred in the simulation state. |
| control'assertNote | Print NOTE level assertion to simulation output. |
| control'assertWarning | Print WARNING level assertion to simulation output. |
| control'assertError | Print ERROR level assertion to simulation output. |
| control'assertFailure | Print FAILURE level assertion to simulation output. |
| now | Gets current (real, IE VHDL) time. |

NOTE:
- `control'jumpTime` is unused.
- `now` is not yet used because function calls are not implemented.

##### Internal Functions
| Function | Description |
| :------- | :---------- |
| anon'stringToString | Convert VHDL `STD.STANDARD.STRING` type to Haskell `String` (`[Char]`) for printing to simulation output. |
| anon'characterToChar | Convert VHDL `STD.STANDARD.CHARACTER` type to Haskell `Char` for printing to simulation output. |

#### Constants
| Constant | Description |
| :------- | :---------- |
| initialTime | Starting time, used for the initial time in initial state declarations. |

### STD.STANDARD
This is the VHDL standard package as specified in IEEE 1076-1987.
Most of this has been autogenerated with this tool, however it also has additional non-standard parts:
- Logical functions (only builtin for types _STD.STANDARD.BOOLEAN_ and _STD.STANDARD.BIT_)
- Haskell typeclass for outputting signals
- Conversion of `Bool` Haskell type to `STD.STANDARD.BOOLEAN` VHDL type (used for autogenerated comparisons)

This is located in `<build-dir>/src/STD/STANDARD.hs`.

## Fully Generated Modules
### Components (Entities and Architectures)
Entities and architectures are outputted in the form of the component modules:
- If no architecture exists for an entity, just the entity is converted to the component
- If an architecture exists then it is merged with the entity and converted to the component

Generated in `Sim.Output.Components` module.

#### Module Names
Entities and architectures names are ignored, they are renamed to a component name:
- `<LIBRARY>.<ENTITY>'COMPONENT'<COMPONENT>`
- `<LIBRARY>.<ENTITY>'COMPONENT'<COMPONENT>'GENERICS` (see [Generics](#Generics))

| Symbol | Meaning |
| :----- | :------ |
| `<LIBRARY>` | Library name |
| `<ENTITY>` | Entity name |
| `<COMPONENT>` | Component name |

##### Component Names
Component names are a list showing the hierarchy from _TOP_ to the current component name.

E.g. For a component name `i_component` imported in the component `i_middle`, where `i_middle` is imported in the module module, the component name would be: `TOP'I_MIDDLE'I_COMPONENT`

#### State
There are three similar components of the state (signals), and one additional part (processes).

##### Signals
- Input ports
- Output ports
- Internal signals

NOTE: Not yet implemented ports of type other than in/out.

```haskell
data <STATEPART> =
   <STATEPART>
      {
         -- List of signals in state
      }
```
Where `<STATEPART>` is:
- `PORTS'IN` for input ports
- `PORTS'OUT` for output ports
- `STATE` for internal signals
And the signal names within the state follow the scheme:
- `ports'in'<PORTNAME>` for input ports
- `ports'out'<PORTNAME>` for output ports
- `signal'<PORTNAME>` for internal signals

###### Default Values
Each state has an associated initial value:
```haskell
initial'<STATEPART> =
   <STATEPART>
      {
         -- List of initial values
      }
```

##### Processes
Processes have an associated state which holds two important data:
- Wait statement state: Particularly for processes with more than one wait statement, this determines where in the sequence of sequential statements the process is currently suspended at
- Wait statement time: The timeout value for the current wait statement the process is at

```haskell
data PROCESSES =
   PROCESSES
      {
         -- Process states
      }
```

##### Process Names
The process states are named according to their label.
If a label is not provided they are give the name `ANON'<ID>`, where `<ID>` is an incrementing integer from 0.

Process states are named `processes'<NAME>` where `<NAME>` is as described above.
The process state has type `(Int,STD.STANDARD.Type'ANON'TIME)`.

###### Default Values
The process initial value is generated in `Sim.Output.Processes` module.

#### Functions
Components have a number of inherent functions defined that are used by the module that instantiates them to interface with the component.

##### Initial State
```haskell
initialStack =
   Entity'State
      initial'PORTS'IN
      initial'STATE
      initial'PORTS'OUT
      initial'PROCESSES
```
A fixed function that uses the internally namespaced initial states to form an entire initial state for the component.

##### All Times
The `allTimes` function is a monadic function with the type signature `Entity'<COMPONENT>'Stack (Maybe STD.STANDARD.Type'ANON'TIME)`.
This returns the next time this component has something to do:
- Wait statement timeout
- Signal update

##### Any Ready
Similar to the `allTimes` function, this monitors whether any signals will update in the next delta.
This is used to check whether the simulation should increment the delta, and remain within the current real time period.
Otherwise, it uses the `allTimes` function to jump to the next time.

##### Initial Update
The `initialUpdate` function calls the `control'printInitial` function for all signals within the component to print initial values of signals.

##### Normal Update
`signalUpdate` function updates the signal values for all signals within the component (and prints the signal values to the output).

##### Component Stack
Type `Entity'<COMPONENT>'Stack` is a custom form of `Entity'Stack` with a state setup for this component.

##### Component Control
The top level control function is `entityControl`, this calls all necessary processes, etc.

#### Generics
To add portability, components are generated the same way no matter how generic and port maps for the component are assigned.
Port values are non-static and part of the state.
Generics are implemented through making a separate file with just these constants.
- The name of this file is `<build-dir>/src/<LIBRARY>/<ENTITY>'COMPONENT'<COMPONENT>'GENERICS`
- This is imported in the component file and is the difference between the same components with different generics

NOTE: Currently, each component is generated separately.
This isn't very efficient, should be generating a single component Haskell module body and attach different headers (with different import statements and module names).
Because they are not independent, each component contains a list (next to the state), showing the values of the imported generics.

#### Top Module
Special case of component

### Packages

## Generated Declarations
